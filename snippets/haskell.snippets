# Source: https://github.com/honza/vim-snippets

snippet lang
	{-# LANGUAGE ${0:OverloadedStrings} #-}
endsnippet

snippet haddock
	{-# OPTIONS_HADDOCK ${0:hide} #-}
endsnippet

snippet ghc
	{-# OPTIONS_GHC ${0:-fno-warn-unused-imports} #-}
endsnippet

snippet inline
	{-# INLINE ${0:name} #-}
endsnippet

snippet info
	-- |
	-- Module      :  ${1:`substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`}
	-- Copyright   :  ${2:Author} ${3:2011-2012}
	-- License     :  ${4:BSD3}
	--
	-- Maintainer  :  ${5:email@something.com}
	-- Stability   :  ${6:experimental}
	-- Portability :  ${7:unknown}
	--
	-- ${0:Description}
	--
endsnippet

snippet imp
	import ${0:Data.Text}
endsnippet

snippet import
	import           ${0:Data.Text}
endsnippet

snippet import2
	import           ${1:Data.Text} (${0:head})
endsnippet

snippet impq
	import qualified ${1:Data.Text} as ${0:T}
endsnippet

snippet importq
	import qualified ${1:Data.Text} as ${0:T}
endsnippet

snippet inst
	instance ${1:Monoid} ${2:Type} where
		${0}
endsnippet

snippet ty
	type ${1:Type} = ${0:Type}
endsnippet

snippet type
	type ${1:Type} = ${0:Type}
endsnippet

snippet da
	data ${1:Type} = ${2:$1} ${0:Int}
endsnippet

snippet data
	data ${1:Type} = ${2:$1} ${0:Int}
endsnippet

snippet newtype
	newtype ${1:Type} = ${2:$1} ${0:Int}
endsnippet

snippet class
	class ${1:Class} a where
		${0}
endsnippet

snippet module
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (
	) where
	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`
endsnippet

snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
		( ${1}
		) where

	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`
endsnippet

snippet main
	main :: IO ()
	main = ${0:undefined}
endsnippet

snippet const
	${1:name} :: ${2:a}
	$1 = ${0:undefined}
endsnippet

snippet fn
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
endsnippet

snippet fn0
	${1:fn} :: ${2:a}
	$1 = ${0:undefined}
endsnippet

snippet fn1
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
endsnippet

snippet fn2
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5} = ${0:undefined}
endsnippet

snippet fn3
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6} = ${0:undefined}
endsnippet

snippet => "Type constraint"
	(${1:Class} ${2:a}) => $2
endsnippet

snippet ap
	${1:map} ${2:fn} ${0:list}
endsnippet

snippet \
	\\${1:x} -> ${0:expression}
endsnippet

snippet (\
	(\\${1:x} -> ${0:expression})
endsnippet

snippet <-
	${1:a} <- ${0:m a}
endsnippet

snippet ->
	${1:m a} -> ${0:a}
endsnippet

snippet tup
	(${1:a}, ${0:b})
endsnippet

snippet tup2
	(${1:a}, ${2:b}, ${0:c})
endsnippet

snippet tup3
	(${1:a}, ${2:b}, ${3:c}, ${0:d})
endsnippet

snippet rec
	${1:Record} { ${2:recFieldA} = ${3:undefined}
				, ${4:recFieldB} = ${0:undefined}
				}
endsnippet

snippet case
	case ${1:something} of
		${2} -> ${0}
endsnippet

snippet let
	let ${1} = ${2}
	in ${3}
endsnippet

snippet where
	where
		${1:fn} = ${0:undefined}
endsnippet

snippet spec
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.QuickCheck

	main :: IO ()
	main = hspec spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0
endsnippet

snippet specf
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.Hspec.Runner (configFastFail, defaultConfig, hspecWith)

	main :: IO ()
	main = hspecWith defaultConfig {configFastFail = True} spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0
endsnippet

snippet desc
	describe "${1}" $ do
		$0
endsnippet

snippet it
	it "${1}" $
		$0
endsnippet

snippet itp
	it "${1}" $ property $
		$0
endsnippet

snippet sb
	\`shouldBe\` $0
endsnippet

snippet doc
	{-| ${0}
	-}
endsnippet

